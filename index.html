<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>majorh5's janky Tiled Map Processor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .glass-container {
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.15);
        }

        .drop-zone {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .drop-zone-default {
            border: 2px dashed #d1d5db;
            background: linear-gradient(145deg, #f9fafb, #f3f4f6);
        }

        .drop-zone-default:hover {
            border-color: #6b7280;
            background: linear-gradient(145deg, #ffffff, #f9fafb);
            transform: translateY(-1px);
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1);
        }

        .drop-zone-selected {
            border: 2px dashed #10b981;
            background: linear-gradient(145deg, #ecfdf5, #d1fae5);
            animation: pulse-green 2s infinite;
        }

        @keyframes pulse-green {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4);
            }

            50% {
                box-shadow: 0 0 0 10px rgba(16, 185, 129, 0);
            }
        }

        .progress-bar {
            background: linear-gradient(90deg, #3b82f6, #1d4ed8, #3b82f6);
            background-size: 200% 100%;
            animation: shimmer 2s infinite linear;
            transition: width 0.3s ease;
        }

        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }

            100% {
                background-position: 200% 0;
            }
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            transition: all 0.2s ease;
        }

        .btn-primary:hover:not(:disabled) {
            background: linear-gradient(135deg, #2563eb, #1e40af);
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -3px rgba(59, 130, 246, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -3px rgba(16, 185, 129, 0.4);
        }

        .step-indicator {
            position: relative;
        }

        .step-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            right: -20px;
            width: 40px;
            height: 2px;
            background: #d1d5db;
            transform: translateY(-50%);
        }

        .step-indicator:last-child::after {
            display: none;
        }

        .step-active {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
        }

        .step-completed {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .icon-spin {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="min-h-screen p-4">
    <div class="max-w-6xl mx-auto">
        <div class="glass-container rounded-xl p-8 mb-8">
            <div class="text-center mb-8">
                <h1
                    class="text-4xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent mb-4">
                    majorh5's janky Tiled Map Processor
                </h1>
                <p class="text-gray-600 text-lg">
                    Complete pipeline: JSON cleanup → LZW compression → Base64 encoding → Image conversion
                </p>
            </div>

            <!-- Process Flow Indicator -->
            <div class="flex justify-center items-center mb-8 space-x-4">
                <div id="step1" class="step-indicator px-4 py-2 rounded-lg bg-gray-200 text-gray-600 font-medium">
                    1. Upload JSON
                </div>
                <div id="step2" class="step-indicator px-4 py-2 rounded-lg bg-gray-200 text-gray-600 font-medium">
                    2. Process & Clean
                </div>
                <div id="step3" class="step-indicator px-4 py-2 rounded-lg bg-gray-200 text-gray-600 font-medium">
                    3. Compress
                </div>
                <div id="step4" class="step-indicator px-4 py-2 rounded-lg bg-gray-200 text-gray-600 font-medium">
                    4. Encode to Image
                </div>
            </div>

            <!-- File Upload Section -->
            <div class="mb-8">
                <div id="dropZone" class="drop-zone drop-zone-default rounded-lg p-8 text-center cursor-pointer">
                    <input type="file" accept=".json" id="fileInput" class="hidden">
                    <div id="uploadPrompt" class="flex flex-col items-center space-y-4">
                        <svg class="w-16 h-16 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                            </path>
                        </svg>
                        <div>
                            <p class="text-xl font-semibold text-gray-700">Drop your Tiled Map JSON file here</p>
                            <p class="text-gray-500">or click to browse (supports large files)</p>
                        </div>
                    </div>
                    <div id="fileSelected" class="hidden flex flex-col items-center space-y-2">
                        <svg class="w-12 h-12 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7">
                            </path>
                        </svg>
                        <p id="fileName" class="text-lg font-semibold text-green-700"></p>
                        <p id="fileSize" class="text-green-600"></p>
                    </div>
                </div>
            </div>

            <!-- Configuration -->
            <div class="mb-8 glass-container p-6 rounded-lg">
                <h3 class="text-lg font-semibold mb-4">Processing Configuration</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="layerToRemove" class="block text-sm font-medium text-gray-700 mb-2">
                            Layer to Remove (optional):
                        </label>
                        <input type="text" id="layerToRemove" value="SO_visuals"
                            class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                    </div>
                    <div>
                        <label for="subPath" class="block text-sm font-medium text-gray-700 mb-2">
                            Sub Path (for naming):
                        </label>
                        <input type="text" id="subPath" value="haven"
                            class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                    </div>
                </div>
            </div>

            <!-- Error Display -->
            <div id="errorDisplay" class="hidden mb-6 bg-red-50 border border-red-200 rounded-lg p-4">
                <div class="flex items-start space-x-2">
                    <svg class="w-5 h-5 text-red-500 mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <div>
                        <p class="font-medium text-red-800">Error</p>
                        <p id="errorMessage" class="text-red-700 text-sm"></p>
                    </div>
                </div>
            </div>

            <!-- Processing Display -->
            <div id="processingDisplay" class="hidden mb-6">
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                    <div class="flex items-center space-x-2 mb-2">
                        <svg id="processingIcon" class="w-5 h-5 text-blue-500 icon-spin" fill="none"
                            stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15">
                            </path>
                        </svg>
                        <span id="processingStatus" class="font-medium text-blue-800">Processing...</span>
                    </div>
                    <div class="w-full bg-blue-100 rounded-full h-3 mb-2">
                        <div id="progressBar" class="progress-bar h-3 rounded-full" style="width: 0%"></div>
                    </div>
                    <p id="progressText" class="text-blue-700 text-sm">0% complete</p>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex space-x-4 mb-8">
                <button id="processBtn" disabled
                    class="btn-primary flex items-center space-x-2 px-6 py-3 rounded-lg font-medium text-white disabled:opacity-50 disabled:cursor-not-allowed">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                    </svg>
                    <span>Process File</span>
                </button>

                <button id="resetBtn"
                    class="bg-gray-500 hover:bg-gray-600 flex items-center space-x-2 px-6 py-3 text-white rounded-lg font-medium transition-all">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15">
                        </path>
                    </svg>
                    <span>Reset</span>
                </button>
            </div>

            <!-- Results Section -->
            <div id="resultsDisplay" class="hidden">
                <div class="bg-green-50 border border-green-200 rounded-lg p-6 mb-6">
                    <div class="flex items-center space-x-2 mb-4">
                        <svg class="w-6 h-6 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7">
                            </path>
                        </svg>
                        <h3 class="text-xl font-bold text-green-800">Processing Complete!</h3>
                    </div>

                    <!-- Statistics -->
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <p class="text-sm text-gray-600">Original Size</p>
                            <p id="statOriginalSize" class="text-lg font-bold text-blue-600">-</p>
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <p class="text-sm text-gray-600">Compressed Size</p>
                            <p id="statCompressedSize" class="text-lg font-bold text-green-600">-</p>
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <p class="text-sm text-gray-600">Compression Ratio</p>
                            <p id="statCompressionRatio" class="text-lg font-bold text-purple-600">-</p>
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <p class="text-sm text-gray-600">Image Dimensions</p>
                            <p id="statImageDimensions" class="text-lg font-bold text-indigo-600">-</p>
                        </div>
                    </div>

                    <!-- Download Buttons -->
                    <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
                        <button id="downloadB64Btn"
                            class="btn-success flex items-center justify-center space-x-2 px-6 py-3 text-white rounded-lg font-medium">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                                </path>
                            </svg>
                            <span>Download Base64 Text</span>
                        </button>

                        <button id="downloadImageBtn"
                            class="btn-success flex items-center justify-center space-x-2 px-6 py-3 text-white rounded-lg font-medium">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                                </path>
                            </svg>
                            <span>Download PNG Image</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden canvas for image processing -->
    <canvas id="canvas" style="display: none;"></canvas>

    <script>
        class TiledMapProcessor {
            constructor() {
                this.selectedFile = null;
                this.isProcessing = false;
                this.results = {
                    base64Data: null,
                    imageData: null,
                    stats: {}
                };

                this.initEventListeners();
            }

            initEventListeners() {
                const dropZone = document.getElementById('dropZone');
                const fileInput = document.getElementById('fileInput');

                dropZone.addEventListener('click', () => fileInput.click());
                dropZone.addEventListener('dragover', this.handleDragOver.bind(this));
                dropZone.addEventListener('dragleave', this.handleDragLeave.bind(this));
                dropZone.addEventListener('drop', this.handleDrop.bind(this));

                fileInput.addEventListener('change', this.handleFileSelect.bind(this));
                document.getElementById('processBtn').addEventListener('click', this.processFile.bind(this));
                document.getElementById('resetBtn').addEventListener('click', this.resetProcessor.bind(this));
                document.getElementById('downloadB64Btn').addEventListener('click', this.downloadBase64.bind(this));
                document.getElementById('downloadImageBtn').addEventListener('click', this.downloadImage.bind(this));
            }

            handleDragOver(e) {
                e.preventDefault();
                document.getElementById('dropZone').classList.remove('drop-zone-default');
                document.getElementById('dropZone').classList.add('drop-zone-selected');
            }

            handleDragLeave(e) {
                e.preventDefault();
                document.getElementById('dropZone').classList.add('drop-zone-default');
                document.getElementById('dropZone').classList.remove('drop-zone-selected');
            }

            handleDrop(e) {
                e.preventDefault();
                document.getElementById('dropZone').classList.add('drop-zone-default');
                document.getElementById('dropZone').classList.remove('drop-zone-selected');

                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].name.toLowerCase().endsWith('.json')) {
                    this.setSelectedFile(files[0]);
                } else {
                    this.showError('Please select a valid JSON file');
                }
            }

            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file && file.name.toLowerCase().endsWith('.json')) {
                    this.setSelectedFile(file);
                } else {
                    this.showError('Please select a valid JSON file');
                }
            }

            setSelectedFile(file) {
                this.selectedFile = file;
                this.updateStepIndicator(1, 'completed');
                this.showFileSelected(file);
                this.hideError();
                this.hideResults();
                document.getElementById('processBtn').disabled = false;
            }

            showFileSelected(file) {
                document.getElementById('uploadPrompt').classList.add('hidden');
                document.getElementById('fileSelected').classList.remove('hidden');
                document.getElementById('fileName').textContent = file.name;
                document.getElementById('fileSize').textContent = this.formatBytes(file.size);

                document.getElementById('dropZone').classList.remove('drop-zone-default');
                document.getElementById('dropZone').classList.add('drop-zone-selected');
            }

            async processFile() {
                if (!this.selectedFile || this.isProcessing) return;

                this.isProcessing = true;
                this.showProcessing();
                this.hideError();
                this.hideResults();
                document.getElementById('processBtn').disabled = true;

                try {
                    // Step 1: Read and parse JSON
                    this.updateStepIndicator(2, 'active');
                    this.updateProgress(10, 'Reading JSON file...');
                    const jsonText = await this.readFile(this.selectedFile);

                    this.updateProgress(20, 'Parsing JSON...');
                    const jsonData = JSON.parse(jsonText);

                    // Step 2: Clean and process JSON
                    this.updateProgress(30, 'Cleaning JSON data...');
                    const cleanedData = await this.cleanJsonData(jsonData);

                    this.updateProgress(40, 'Minifying JSON...');
                    const minifiedJson = JSON.stringify(cleanedData, null, 0);
                    this.updateStepIndicator(2, 'completed');


                    // Step 3: Compress with LZW and encode to Base64
                    this.updateStepIndicator(3, 'active');
                    this.updateProgress(50, 'Compressing with LZW...');
                    const compressedDataBase64 = await this.deflateCompress(minifiedJson);
                    console.log(compressedDataBase64, minifiedJson.substring(minifiedJson.length - 100, minifiedJson.length));

                    /*
                    const blob = new Blob([compressedData], { type: "application/octet-stream" });

                    // Create a temporary link element
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(blob);
                    link.download = 'compressed.txt';

                    // Append to DOM, click to trigger download, then remove
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);

                    // Release memory
                    URL.revokeObjectURL(link.href);

                    this.updateProgress(60, 'Encoding to Base64...');
                    const base64Data = this.encodeBase64(compressedData);
                    this.updateStepIndicator(3, 'completed');
                    */

                    // Step 4: Convert to image
                    this.updateStepIndicator(4, 'active');
                    this.updateProgress(70, 'Converting to image...');
                    const imageResult = await this.convertToImage(compressedDataBase64);
                    this.updateStepIndicator(4, 'completed');

                    // Store results
                    this.results.base64Data = compressedDataBase64;
                    this.results.imageData = imageResult;
                    this.results.stats = {
                        originalSize: jsonText.length,
                        compressedSize: compressedDataBase64.length,
                        base64Size: compressedDataBase64.length,
                        compressionRatio: ((jsonText.length - compressedDataBase64.length) / jsonText.length * 100).toFixed(1),
                        imageDimensions: `${imageResult.width}×${imageResult.height}`
                    };

                    this.updateProgress(100, 'Processing complete!');
                    this.hideProcessing();
                    this.showResults();

                } catch (error) {
                    this.hideProcessing();
                    this.showError(`Processing failed: ${error.message}`);
                    this.resetStepIndicators();
                } finally {
                    this.isProcessing = false;
                    if (this.selectedFile) {
                        document.getElementById('processBtn').disabled = false;
                    }
                }
            }


            // Replace the readFile method with this memory-optimized version
            async readFile(file) {
                // For files larger than 10MB, use a different approach
                if (file.size > 10 * 1024 * 1024) {
                    return this.readLargeFile(file);
                }

                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }

            // New method specifically for large files
            async readLargeFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    const chunkSize = 512 * 1024; // Smaller 512KB chunks for better memory management
                    let offset = 0;
                    const chunks = []; // Store chunks in array instead of concatenating strings
                    let totalChunks = Math.ceil(file.size / chunkSize);
                    let processedChunks = 0;

                    const readChunk = () => {
                        if (offset >= file.size) {
                            // Join all chunks at once - more memory efficient than incremental concatenation
                            try {
                                const result = chunks.join('');
                                chunks.length = 0; // Clear chunks array to free memory
                                resolve(result);
                            } catch (error) {
                                reject(new Error('File too large to process in browser memory'));
                            }
                            return;
                        }

                        const slice = file.slice(offset, offset + chunkSize);
                        const chunkReader = new FileReader();

                        chunkReader.onload = (e) => {
                            chunks.push(e.target.result);
                            offset += chunkSize;
                            processedChunks++;

                            // Update progress
                            const progress = Math.min((processedChunks / totalChunks) * 15, 15);
                            this.updateProgress(progress, `Reading file... ${Math.round((processedChunks / totalChunks) * 100)}%`);

                            // Longer delay for large files to prevent browser freezing
                            setTimeout(readChunk, 10);
                        };

                        chunkReader.onerror = (error) => {
                            reject(new Error('Failed to read file chunk: ' + error.message));
                        };

                        chunkReader.readAsText(slice);
                    };

                    readChunk();
                });
            }

            async cleanJsonData(data) {
                const layerToRemove = document.getElementById('layerToRemove').value.trim();

                // Remove specified layer
                if (data.layers && layerToRemove) {
                    data.layers = data.layers.filter(layer => layer.name !== layerToRemove);
                }

                // Remove base object keys
                const keysToRemoveBase = [
                    'compressionlevel', 'infinite', 'type', 'version', 'tilewidth',
                    'tileheight', 'spacing', 'orientation', 'tiledversion',
                    'imagewidth', 'imageheight', 'margin', 'image', 'columns',
                    'renderorder', 'nextlayerid', 'nextobjectid'
                ];

                keysToRemoveBase.forEach(key => {
                    if (key in data) delete data[key];
                });

                // Clean tilesets
                if (data.tilesets) {
                    const keysToRemoveTileset = [
                        'tilecount', 'tilewidth', 'tileheight', 'spacing',
                        'imagewidth', 'imageheight', 'margin', 'image', 'columns'
                    ];

                    data.tilesets.forEach(tileset => {
                        keysToRemoveTileset.forEach(key => {
                            if (key in tileset) delete tileset[key];
                        });
                    });
                }

                // Clean layers
                if (data.layers) {
                    const keysToRemoveLayer = [
                        'opacity', 'x', 'y', 'width', 'height', 'id',
                        'visible', 'draworder'
                    ];

                    data.layers.forEach(layer => {
                        keysToRemoveLayer.forEach(key => {
                            if (key in layer) delete layer[key];
                        });
                    });
                }

                return data;
            }


            async deflateCompress(data) {
                try {
                    this.updateProgress(50, 'Starting compression...');

                    // Create a single compression stream for the entire data
                    const stream = new CompressionStream('deflate');
                    const writer = stream.writable.getWriter();
                    const reader = stream.readable.getReader();

                    // Collect all compressed chunks
                    const compressedChunks = [];

                    // Start reading compressed data
                    const readPromise = (async () => {
                        try {
                            while (true) {
                                const { value, done } = await reader.read();
                                if (done) break;
                                if (value) compressedChunks.push(value);
                            }
                        } finally {
                            reader.releaseLock();
                        }
                    })();

                    // Write data in chunks to avoid memory issues
                    const writePromise = (async () => {
                        try {
                            const chunkSize = 1024 * 1024; // 1MB chunks
                            const totalChunks = Math.ceil(data.length / chunkSize);

                            for (let i = 0; i < totalChunks; i++) {
                                const start = i * chunkSize;
                                const end = Math.min(start + chunkSize, data.length);

                                let chunk;
                                if (typeof data === 'string') {
                                    // If data is string, encode the slice
                                    chunk = new TextEncoder().encode(data.slice(start, end));
                                } else {
                                    // If data is already Uint8Array or similar, just slice
                                    chunk = data.slice(start, end);
                                }

                                await writer.write(chunk);

                                // Update progress
                                const progress = 50 + ((i + 1) / totalChunks) * 30;
                                this.updateProgress(progress, `Compressing chunk ${i + 1}/${totalChunks}...`);

                                // Yield control periodically
                                if (i % 10 === 0) {
                                    await new Promise(resolve => setTimeout(resolve, 0));
                                }
                            }
                        } finally {
                            await writer.close();
                        }
                    })();

                    // Wait for both reading and writing to complete
                    await Promise.all([writePromise, readPromise]);

                    this.updateProgress(80, 'Combining compressed data...');

                    // Combine all compressed chunks
                    const totalLength = compressedChunks.reduce((acc, chunk) => acc + chunk.length, 0);
                    const finalCompressed = new Uint8Array(totalLength);
                    let offset = 0;

                    for (const chunk of compressedChunks) {
                        finalCompressed.set(chunk, offset);
                        offset += chunk.length;
                    }

                    this.updateProgress(90, 'Converting to base64...');

                    // Convert to base64
                    return this.arrayToBase64Chunked(finalCompressed);

                } catch (error) {
                    throw new Error(`Compression failed: ${error.message}`);
                }
            }

            // Helper method to convert large arrays to base64 without stack overflow
            arrayToBase64Chunked(uint8Array) {
                const chunkSize = 8192; // 8KB chunks for base64 conversion
                let result = '';

                for (let i = 0; i < uint8Array.length; i += chunkSize) {
                    const end = Math.min(i + chunkSize, uint8Array.length);
                    const chunk = uint8Array.slice(i, end);
                    const chunkString = String.fromCharCode.apply(null, chunk);
                    result += btoa(chunkString);
                }

                return result;
            }

            encodeBase64(data) {
                const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                let result = '';

                for (let i = 0; i < data.length; i += 3) {
                    const a = data.charCodeAt(i) || 0;
                    const b = data.charCodeAt(i + 1) || 0;
                    const c = data.charCodeAt(i + 2) || 0;

                    const bitmap = (a << 16) | (b << 8) | c;

                    result += base64Chars.charAt((bitmap >> 18) & 63);
                    result += base64Chars.charAt((bitmap >> 12) & 63);
                    result += base64Chars.charAt((bitmap >> 6) & 63);
                    result += base64Chars.charAt(bitmap & 63);
                }

                // Add padding
                const padding = (3 - (data.length % 3)) % 3;
                for (let i = 0; i < padding; i++) {
                    result = result.slice(0, -1) + '=';
                }

                return result;
            }

            async convertToImage(text) {
                return new Promise((resolve, reject) => {
                    try {
                        // Convert text to bytes
                        const textBytes = new TextEncoder().encode(text);

                        // Calculate optimal dimensions (each pixel stores 3 bytes in RGB channels)
                        const pixelsNeeded = Math.ceil(textBytes.length / 3);
                        let width = Math.ceil(Math.sqrt(pixelsNeeded));
                        let height = Math.ceil(pixelsNeeded / width);

                        // Ensure we don't exceed reasonable limits (using 1024x1024 like the React version)
                        if (width > 1024 || height > 1024) {
                            if (pixelsNeeded > 1024 * 1024) {
                                reject(new Error(`Data too large: requires ${pixelsNeeded} pixels but maximum is ${1024 * 1024} pixels`));
                                return;
                            }

                            width = Math.min(1024, width);
                            height = Math.ceil(pixelsNeeded / width);

                            if (height > 1024) {
                                height = 1024;
                                width = Math.ceil(pixelsNeeded / height);
                            }
                        }

                        // Get canvas and context
                        const canvas = document.getElementById('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');

                        // Create image data
                        const imageData = ctx.createImageData(width, height);
                        const data = imageData.data;

                        // Encode text bytes into image data
                        for (let i = 0; i < textBytes.length; i++) {
                            const pixelIndex = Math.floor(i / 3);
                            const channelIndex = i % 3;
                            const dataIndex = pixelIndex * 4 + channelIndex;

                            if (dataIndex < data.length) {
                                data[dataIndex] = textBytes[i];
                            }
                        }

                        // Set alpha channel to 255 for all used pixels
                        for (let i = 0; i < Math.ceil(textBytes.length / 3); i++) {
                            const alphaIndex = i * 4 + 3;
                            if (alphaIndex < data.length) {
                                data[alphaIndex] = 255;
                            }
                        }

                        // Fill remaining pixels with zeros and full alpha
                        for (let i = Math.ceil(textBytes.length / 3) * 4; i < data.length; i += 4) {
                            data[i] = 0;     // R
                            data[i + 1] = 0; // G
                            data[i + 2] = 0; // B
                            data[i + 3] = 255; // A
                        }

                        // Put image data on canvas
                        ctx.putImageData(imageData, 0, 0);

                        // Convert to blob and return result
                        canvas.toBlob((blob) => {
                            if (blob) {
                                resolve({
                                    blob,
                                    width,
                                    height,
                                    url: URL.createObjectURL(blob)
                                });
                            } else {
                                reject(new Error('Failed to create image blob'));
                            }
                        }, 'image/png');

                    } catch (error) {
                        reject(error);
                    }
                });
            }

            updateStepIndicator(step, status) {
                const stepElement = document.getElementById(`step${step}`);
                stepElement.classList.remove('step-active', 'step-completed');

                if (status === 'active') {
                    stepElement.classList.add('step-active');
                } else if (status === 'completed') {
                    stepElement.classList.add('step-completed');
                }
            }

            resetStepIndicators() {
                for (let i = 1; i <= 4; i++) {
                    const stepElement = document.getElementById(`step${i}`);
                    stepElement.classList.remove('step-active', 'step-completed');
                }
            }

            updateProgress(percentage, status) {
                document.getElementById('progressBar').style.width = percentage + '%';
                document.getElementById('progressText').textContent = `${percentage.toFixed(1)}% complete`;
                document.getElementById('processingStatus').textContent = status;
            }

            showProcessing() {
                document.getElementById('processingDisplay').classList.remove('hidden');
            }

            hideProcessing() {
                document.getElementById('processingDisplay').classList.add('hidden');
            }

            showError(message) {
                document.getElementById('errorMessage').textContent = message;
                document.getElementById('errorDisplay').classList.remove('hidden');
            }

            hideError() {
                document.getElementById('errorDisplay').classList.add('hidden');
            }

            showResults() {
                const stats = this.results.stats;
                document.getElementById('statOriginalSize').textContent = this.formatBytes(stats.originalSize);
                document.getElementById('statCompressedSize').textContent = this.formatBytes(stats.compressedSize);
                document.getElementById('statCompressionRatio').textContent = `${stats.compressionRatio}%`;
                document.getElementById('statImageDimensions').textContent = stats.imageDimensions;

                document.getElementById('resultsDisplay').classList.remove('hidden');
            }

            hideResults() {
                document.getElementById('resultsDisplay').classList.add('hidden');
            }

            downloadBase64() {
                if (!this.results.base64Data) return;

                const subPath = document.getElementById('subPath').value.trim() || 'processed';
                const filename = `${subPath}_map_compressed.txt`;

                const blob = new Blob([this.results.base64Data], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');

                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            downloadImage() {
                if (!this.results.imageData) return;

                const subPath = document.getElementById('subPath').value.trim() || 'processed';
                const filename = `${subPath}_map_encoded.png`;

                const a = document.createElement('a');
                a.href = this.results.imageData.url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

            resetProcessor() {
                this.selectedFile = null;
                this.isProcessing = false;
                this.results = { base64Data: null, imageData: null, stats: {} };

                document.getElementById('fileInput').value = '';
                document.getElementById('uploadPrompt').classList.remove('hidden');
                document.getElementById('fileSelected').classList.add('hidden');
                document.getElementById('dropZone').classList.remove('drop-zone-selected');
                document.getElementById('dropZone').classList.add('drop-zone-default');
                document.getElementById('processBtn').disabled = true;

                this.hideError();
                this.hideProcessing();
                this.hideResults();
                this.resetStepIndicators();
                this.updateStepIndicator(1, 'active');
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }
        }

        // Initialize the processor when the page loads
        document.addEventListener('DOMContentLoaded', function () {
            new TiledMapProcessor();
        });
    </script>
</body>

</html>